Okay, I will implement the feature automation process as requested. This will involve creating a main bash script, example configuration files, a `CLAUDE_AGENT_RULES.md` file, and an updated `README.md`. The tool will be structured to be placed within a user's repository, typically in a subdirectory.

Here's a breakdown of the files that will be created or modified:

1.  **`.gitignore`**: I will clean up and rationalize the provided `.gitignore` file.
2.  **`auto_feature_tool/auto_feature.sh`**: The main bash script to orchestrate the process.
3.  **`auto_feature_tool/config.sh.example`**: An example configuration file for users to copy and customize.
4.  **`auto_feature_tool/features_to_implement.txt.example`**: An example input file showing how users should list features.
5.  **`auto_feature_tool/CLAUDE_AGENT_RULES.md`**: Guidelines for the `claude-code` AI agent.
6.  **`auto_feature_tool/.claude/commands/.gitkeep`**: To ensure the directory structure for temporary Claude commands is present. (Claude might create this dir itself, but good to have a placeholder).
7.  **`README.md`**: Updated to explain the new tool, its setup, and usage.

Let's start by creating these files.

First, a cleaned-up and consolidated `.gitignore`:

```text
# --- Global ---
.DS_Store
Thumbs.db
ehthumbs.db
desktop.ini
.directory

# --- Environment Files ---
.env
.env.*
.env.local
.env.development
.env.test
.env.production
env.bak/
# For the auto_feature_tool specifically
auto_feature_tool/config.sh

# --- Python ---
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.so
*.egg-info/
*.egg
*.log
*.sqlite3
*.db
*.tmp
*.bak
*.swp
*$py.class
.Python
# Python virtual environments
.venv/
venv/
ENV/
env/
virtualenv/
infra/venv/ # Example specific to a project structure

# --- Python Tools ---
# pytest
.cache/ # General cache, can be from pytest or other tools
.pytest_cache/
# Jupyter
.ipynb_checkpoints/
*.ipynb # Note: some projects version control notebooks, user may want to unignore
# mypy
.mypy_cache/
.dmypy.json
.pyre/
# nox
.nox/

# --- Node / React / Frontend ---
node_modules/ # Prefer **/node_modules/ for any level
dist/         # Prefer **/dist/
build/        # Prefer **/build/
.next/        # Prefer **/.next/
.nuxt/        # Prefer **/.nuxt/
coverage/     # Prefer **/coverage/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
# Vite / CRA / TypeScript
.vite/
*.tsbuildinfo

# --- IDEs / Editors ---
.vscode/
.idea/
*.code-workspace
*.swp
*.swo

# --- Build Artifacts ---
*.so # Duplicates Python section, but often for C/C++ extensions too
*.dylib
*.dll
*.exe

# --- Tool Specific ---
# Turborepo
.turbo/
# Aider (as per user's original README instruction to NOT use Aider, but good to ignore its artifacts)
.aider*
# This tool's generated content (user can decide to version docs/guides)
# docs/guides/*.md
# This tool's specific temporary files (if not cleaned up, though script should clean up)
# auto_feature_tool/.claude/commands/current_feature_task.md

# --- Repo specific generated files from original .gitignore ---
docs/living_context/*.md
docs/prd/last_response.json
docs/prd/last_request.json
feature_symphony_tool/runs/
# Example of ignoring a specific test project, adapt as needed
# test_project/**

# Code builder artifacts (if config contains secrets or runs are large/temporary)
# These seem specific to another tool, keep if relevant to the broader project context.
# code_builder/runs/
# code_builder/config.yaml # If API keys are stored directly (NOT RECOMMENDED)
# code_builder/.env        # If using a .env file for API keys


# --- Global Ignores (using ** for any directory depth) ---
**/node_modules/
**/dist/
**/build/
**/.next/
**/.nuxt/
**/.cache/ # General cache, also used by various tools like Next.js, pytest
**/coverage/
**/tmp/
**/temp/
**/.tmp/
**/.temp/
**/logs/
**/*.log # General log files

# --- Input file for this repo's context ---
# This file is generated by a 'git dump' command as per the README
repo_contents.txt

# --- Keep .gitkeep files ---
!**/.gitkeep

```

Now, let's create the files for the `auto_feature_tool`.

```text
auto_feature_tool/CLAUDE_AGENT_RULES.md
auto_feature_tool/config.sh.example
auto_feature_tool/features_to_implement.txt.example
auto_feature_tool/auto_feature.sh
auto_feature_tool/.claude/commands/.gitkeep
```

Here's the content for each:

**`auto_feature_tool/CLAUDE_AGENT_RULES.md`**:
```markdown
# Claude Code Agent Development Guidelines

You are an AI Coding Assistant working with the `claude-code` CLI tool. Adhere to the following guidelines strictly for every feature you implement:

## 1. Environment and Setup
- **Virtual Environment**: Assume all Python projects use a virtual environment (e.g., `.venv` or `venv`). If you need to install packages, mention the `pip install -r requirements.txt` or `pip install <package>` command that should be run within the activated virtual environment. Do not attempt to activate it yourself, but write code that assumes it *is* active.
- **Project Structure**: Respect the existing project structure. Place new files in appropriate directories.

## 2. Coding Standards
- **Clarity and Readability**: Write clean, maintainable, and well-documented code.
- **Language Best Practices**: Follow idiomatic conventions for the programming language(s) in use.
- **Existing Patterns**: Try to follow existing coding patterns and styles within the project.

## 3. Testing
- **Write Tests**: For any new feature or functionality, write corresponding unit tests. If the project has a testing framework (e.g., pytest, unittest, Jest), use it.
- **Test Coverage**: Aim for good test coverage for the code you add or modify.
- **All Tests Pass**: Before concluding your work on a feature, ensure all tests (new and existing) pass. You can typically run tests with commands like `pytest`, `npm test`, etc. State the command you would use to run tests.

## 4. Code Execution and Confirmation
- **Runnable Code**: Ensure the code you write is runnable.
- **Active Confirmation**: Where possible, describe how you would manually or programmatically confirm that the core functionality of your implemented feature works as expected. This might involve running a specific script, a server, or making an API call. For example: "To confirm, run `python main.py` and observe X" or "Start the server with `npm run dev` and navigate to Y route".

## 5. Version Control (Git)
- **Staging**: After implementing and testing, stage all relevant changes using `/git add .` or `/git add <specific_files>`. Be precise if possible.
- **Committing**: Commit the staged changes with a clear, descriptive, and conventional commit message. The main script will usually provide you with a suggested commit message format like `feat: Implement <Feature Name>`. Use that.
- **Branching**: Do not create new branches unless explicitly told to. Assume you are working on the current branch.

## 6. Interaction and Output
- **Clarity**: Clearly state the actions you've taken, files created/modified, and tests run.
- **Autonomous Operation**: The `--dangerously-skip-permissions` flag will be used. You are expected to proceed with file modifications and git operations without asking for interactive confirmation once you've decided on a plan based on the provided guide and these rules.

By following these rules, you will help ensure high-quality, well-tested, and maintainable contributions to the project.
```

**`auto_feature_tool/config.sh.example`**:
```bash
#!/bin/bash

# -----------------------------------------------------------------------------
# Configuration for AI Feature Implementation Script
# -----------------------------------------------------------------------------
# Copy this file to 'config.sh' in the same directory and customize the values.
# IMPORTANT: Add 'auto_feature_tool/config.sh' to your project's .gitignore file
# if it's not already covered by a more general pattern.
# -----------------------------------------------------------------------------

# --- OpenRouter API Configuration ---
# Your OpenRouter API Key. Get one from https://openrouter.ai
export OPENROUTER_API_KEY="YOUR_OPENROUTER_API_KEY_HERE"

# Model to use for generating implementation guides (via OpenRouter)
# Example: "google/gemini-1.5-pro-latest", "openai/gpt-4o", "anthropic/claude-3-opus"
# The user's request specified "gemini 2.5 pro". Ensure this model identifier is correct on OpenRouter.
export GEMINI_MODEL="google/gemini-2.5-pro" # Verify this model string on OpenRouter

# Optional headers for OpenRouter API calls (helps your app appear on leaderboards)
export OPENROUTER_SITE_URL="<YOUR_SITE_URL_OR_PROJECT_URL>" # e.g., https://yourproject.com
export OPENROUTER_SITE_NAME="<YOUR_APP_OR_PROJECT_NAME>"    # e.g., MyProject FeatureGen

# --- File Path Configurations (relative to the project root) ---
# Path to the file containing the overall project context.
export PROJECT_CONTEXT_PATH="project_context.md"

# Path to the 'repo_contents.txt' file (output of 'git dump' or similar command).
export REPO_CONTENTS_PATH="repo_contents.txt"

# Path to the file containing the list of features to implement.
export FEATURES_FILE_PATH="features_to_implement.txt"

# Path to the CLAUDE_AGENT_RULES.md file.
# Default assumes it's within the auto_feature_tool directory.
export CLAUDE_RULES_PATH="auto_feature_tool/CLAUDE_AGENT_RULES.md"

# Directory where generated implementation guides will be stored.
export GUIDES_DIR="docs/guides"

# --- Script Behavior ---
# Set to "true" to pause the script for human review after each feature is implemented by Claude.
# Set to "false" for fully autonomous operation.
export HUMAN_REVIEW="false"

# --- Claude Code Configuration ---
# Path to the claude CLI executable, if not in system PATH or if you want to specify one.
# Default is "claude", assuming it's in PATH.
# export CLAUDE_CLI_PATH="claude"

# Directory for temporary Claude slash commands (relative to project root).
# claude-code usually looks for .claude/commands in the current working directory.
export CLAUDE_TEMP_COMMANDS_DIR=".claude/commands"

# --- Sanity Checks ---
if [[ "${OPENROUTER_API_KEY}" == "YOUR_OPENROUTER_API_KEY_HERE" || -z "${OPENROUTER_API_KEY}" ]]; then
  echo "ERROR: OPENROUTER_API_KEY is not set in auto_feature_tool/config.sh. Please set it." >&2
  # exit 1 # The main script will handle exit
fi

```

**`auto_feature_tool/features_to_implement.txt.example`**:
```text
Feature: Implement User Login
Description:
Develop a secure user login page with username and password fields.
Upon successful authentication, redirect users to their dashboard.
Include error handling for invalid credentials.
--- FEATURE SEPARATOR ---
Feature: Add User Profile Page
Description:
Create a page where logged-in users can view and edit their profile information.
Profile information should include username, email, and an optional bio.
Ensure data is saved persistently.
--- FEATURE SEPARATOR ---
Feature: Setup Basic API Endpoint for Items
Description:
Create a REST API endpoint GET /api/items that returns a list of predefined items.
Items should be in JSON format.
Example item structure: { "id": 1, "name": "Sample Item", "price": 10.99 }
```

**`auto_feature_tool/.claude/commands/.gitkeep`**:
(This is an empty file, just to ensure the directory can be committed if desired, and to indicate where claude-code temporary commands will be written by the script.)

**`auto_feature_tool/auto_feature.sh`**:
```bash
#!/bin/bash

# Script to automate feature implementation using AI tools.
# Orchestrates Gemini (via OpenRouter) for planning and Claude Code for implementation.

set -e # Exit immediately if a command exits with a non-zero status.
# set -u # Treat unset variables as an error. # Temporarily disabled for SCRIPT_DIR
# set -o pipefail # Causes a pipeline to return the exit status of the last command in the pipe that failed.

# --- Configuration and Setup ---
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
CONFIG_FILE="${SCRIPT_DIR}/config.sh"

if [ ! -f "$CONFIG_FILE" ]; then
    echo "ERROR: Configuration file not found: $CONFIG_FILE"
    echo "Please copy ${CONFIG_FILE}.example to $CONFIG_FILE and customize it."
    exit 1
fi
source "$CONFIG_FILE"

# Validate essential configuration
if [[ "${OPENROUTER_API_KEY}" == "YOUR_OPENROUTER_API_KEY_HERE" || -z "${OPENROUTER_API_KEY}" ]]; then
  echo "ERROR: OPENROUTER_API_KEY is not set or is still the default placeholder in $CONFIG_FILE." >&2
  exit 1
fi

# Ensure necessary commands are available
if ! command -v jq &> /dev/null; then
    echo "ERROR: jq is not installed. Please install jq to parse JSON responses."
    exit 1
fi
CLAUDE_EXEC=${CLAUDE_CLI_PATH:-claude}
if ! command -v "$CLAUDE_EXEC" &> /dev/null; then
    echo "ERROR: Claude Code CLI ('$CLAUDE_EXEC') not found. Please install it (e.g., npm install -g @anthropic-ai/claude-code) and ensure it's in your PATH or configured in config.sh."
    exit 1
fi

# Ensure context files exist
if [ ! -f "$PROJECT_CONTEXT_PATH" ]; then
    echo "ERROR: Project context file not found: $PROJECT_CONTEXT_PATH"
    exit 1
fi
if [ ! -f "$REPO_CONTENTS_PATH" ]; then
    echo "ERROR: Repository contents file not found: $REPO_CONTENTS_PATH"
    exit 1
fi
if [ ! -f "$FEATURES_FILE_PATH" ]; then
    echo "ERROR: Features file not found: $FEATURES_FILE_PATH"
    exit 1
fi
if [ ! -f "$CLAUDE_RULES_PATH" ]; then
    echo "ERROR: Claude rules file not found: $CLAUDE_RULES_PATH"
    exit 1
fi

# Create output directories if they don't exist
mkdir -p "$GUIDES_DIR"
mkdir -p "$CLAUDE_TEMP_COMMANDS_DIR"

# --- Helper Functions ---
log_info() {
    echo "[INFO] $1"
}

log_error() {
    echo "[ERROR] $1" >&2
}

# Function to sanitize feature name for filenames
sanitize_filename() {
    echo "$1" | tr '[:upper:]' '[:lower:]' | tr -s '[:punct:][:space:]' '_' | sed 's/__*/_/g' | sed 's/^_//;s/_$//'
}

# --- Main Logic ---
log_info "Starting feature implementation process..."

# Read context files
project_context_content=$(<"$PROJECT_CONTEXT_PATH")
repo_contents_content=$(<"$REPO_CONTENTS_PATH")
claude_rules_content=$(<"$CLAUDE_RULES_PATH") # Not directly injected, path is used by claude

# Read and parse features file
features_string=$(<"$FEATURES_FILE_PATH")
# Use awk for robust splitting and handling of the delimiter
IFS=$'\n' read -d '' -r -a features_array < <(awk 'BEGIN{RS="--- FEATURE SEPARATOR ---"} {gsub(/(^[ \t\n]+)|([ \t\n]+$)/, ""); print $0}' "$FEATURES_FILE_PATH" && printf '\0')


feature_index=0
for feature_block in "${features_array[@]}"; do
    feature_block_trimmed=$(echo "$feature_block" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    if [ -z "$feature_block_trimmed" ]; then
        continue # Skip empty blocks
    fi

    feature_index=$((feature_index + 1))

    # Extract Feature Name
    feature_name_line=$(echo "$feature_block_trimmed" | grep -m1 "^Feature:")
    current_feature_name=$(echo "$feature_name_line" | sed 's/^Feature:[[:space:]]*//')

    # Extract Description
    desc_line_num=$(echo "$feature_block_trimmed" | grep -n -m1 "^Description:" | cut -d: -f1)
    if [ -n "$desc_line_num" ]; then
        current_feature_description=$(echo "$feature_block_trimmed" | tail -n "+$((desc_line_num))" | sed '1s/^Description:[[:space:]]*//' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
    else
        log_error "Feature '$current_feature_name' is missing a 'Description:' section. Skipping."
        continue
    fi

    if [[ -z "$current_feature_name" ]]; then
        log_warn "Skipping feature block $feature_index with no parsable name."
        continue
    fi

    log_info "Processing Feature ${feature_index}: ${current_feature_name}"

    # 1. Generate Implementation Document (Gemini via OpenRouter)
    sanitized_name=$(sanitize_filename "$current_feature_name")
    guide_filename="${feature_index}_${sanitized_name}_change.md"
    guide_path="${GUIDES_DIR}/${guide_filename}"

    log_info "Generating implementation guide using ${GEMINI_MODEL}..."
    gemini_prompt="You are an expert software architect. Given the following project context, repository contents, and a specific feature request, generate a detailed step-by-step implementation plan in Markdown format. This plan will be used by an AI coding assistant (Claude Code) to write the actual code. The plan should be clear, actionable, and provide enough detail for the AI to understand the requirements, necessary code changes, new files to create, and expected outcomes.

Feature Request:
Title: ${current_feature_name}
Description:
${current_feature_description}

Project Context:
---
${project_context_content}
---

Repository Contents (structure and key file snippets):
---
${repo_contents_content}
---

Produce only the Markdown implementation plan."

    # Prepare JSON payload for OpenRouter
    json_payload=$(jq -n \
        --arg model "$GEMINI_MODEL" \
        --arg prompt "$gemini_prompt" \
        '{model: $model, messages: [{role: "user", content: $prompt}]}')

    response_file=$(mktemp)
    http_code=$(curl -s -w "%{http_code}" -o "$response_file" \
        -X POST "https://openrouter.ai/api/v1/chat/completions" \
        -H "Authorization: Bearer ${OPENROUTER_API_KEY}" \
        -H "Content-Type: application/json" \
        -H "HTTP-Referer: ${OPENROUTER_SITE_URL}" \
        -H "X-Title: ${OPENROUTER_SITE_NAME}" \
        -d "$json_payload")

    if [[ "$http_code" -ne 200 ]]; then
        log_error "OpenRouter API call failed with HTTP status $http_code. Response:"
        cat "$response_file"
        rm "$response_file"
        continue # Skip to next feature
    fi

    implementation_guide=$(jq -r '.choices[0].message.content' "$response_file")
    rm "$response_file"

    if [[ -z "$implementation_guide" || "$implementation_guide" == "null" ]]; then
        log_error "Failed to generate implementation guide or got empty response from OpenRouter for feature: $current_feature_name"
        continue
    fi

    echo "$implementation_guide" > "$guide_path"
    log_info "Implementation guide saved to: $guide_path"

    # 2. Implement with Claude Code
    temp_claude_command_name="feature_${feature_index}_${sanitized_name}_task"
    # Ensure temp_claude_command_name is valid for claude commands (alphanumeric, -, _)
    temp_claude_command_name_sanitized=$(echo "$temp_claude_command_name" | tr -s '[:punct:][:space:]' '_' | sed 's/__*/_/g' | sed 's/^_//;s/_$//' | tr '[:upper:]' '[:lower:]')
    temp_claude_command_file="${CLAUDE_TEMP_COMMANDS_DIR}/${temp_claude_command_name_sanitized}.md"
    
    # Ensure CLAUDE_RULES_PATH is absolute or relative to PWD
    # If CLAUDE_RULES_PATH is relative, it should be relative to where the script is run (project root)
    # The guide_path is already relative to project root or absolute.

    # Construct the content for the temporary Claude slash command
    # Using real paths for claude-code to read, assuming claude-code runs in PWD (project root)
    cat << EOF > "$temp_claude_command_file"
Your current task is to implement the feature: "${current_feature_name}".

1.  First, carefully read and understand the detailed implementation plan provided in the file: \`${guide_path}\`
    You can use the command: \`/read "${guide_path}"\` to load it.

2.  After understanding the plan, proceed to implement all necessary code changes, create new files, and modify existing ones as described.

3.  While working, you MUST strictly adhere to all guidelines specified in the document located at \`${CLAUDE_RULES_PATH}\`.
    If you are unsure about these rules, you can use \`/read "${CLAUDE_RULES_PATH}"\` to review them.

4.  Key development practices to follow (as per the rules):
    *   Write unit tests for new functionality and ensure all tests pass.
    *   Confirm that the implemented code runs correctly and the feature works as expected.
    *   Clearly state what tests you ran or how you verified the functionality.

5.  Once you have successfully implemented the feature, verified it, and ensured tests pass:
    *   Stage all relevant changes using an appropriate git add command (e.g., \`/git add .\` or list specific files).
    *   Commit the changes with the exact commit message: \`feat: Implement ${current_feature_name}\`
       (Use the command: \`/git commit -m "feat: Implement ${current_feature_name}"\`)

Execute all these steps autonomously and comprehensively. Begin by reading the implementation plan.
EOF

    log_info "Attempting to implement feature '${current_feature_name}' using Claude Code..."
    log_info "Claude Code will use the temporary command: /project:${temp_claude_command_name_sanitized}"
    log_info "Task details written to: ${temp_claude_command_file}"
    
    # Run Claude Code non-interactively with the prepared slash command
    # The --dangerously-skip-permissions flag is crucial for automation
    if "$CLAUDE_EXEC" -p "/project:${temp_claude_command_name_sanitized}" --dangerously-skip-permissions; then
        log_info "Claude Code finished processing for feature: ${current_feature_name}"
    else
        log_error "Claude Code command failed for feature: ${current_feature_name}. Check Claude's output for details."
        # Decide if script should stop or continue
        # For now, it will continue with the next feature if 'set -e' is not active for this block
    fi
    
    # Clean up temporary claude command file
    rm -f "$temp_claude_command_file"
    log_info "Cleaned up temporary Claude command file: $temp_claude_command_file"

    # 3. Human Review (if enabled)
    if [[ "$HUMAN_REVIEW" == "true" ]]; then
        echo ""
        log_info "Feature '${current_feature_name}' implementation attempt complete."
        echo "Please review the changes made by Claude Code."
        echo "Git status:"
        git status -s
        echo "Press Enter to continue to the next feature, or Ctrl+C to abort."
        read -r
    fi

done

log_info "All features processed."
exit 0

```
**Updating `README.md`**:
I'll append the explanation of this new tool to the existing `README.md`.
```markdown

---

## AI Feature Implementation Automation Tool

This repository includes a tool to automate the process of implementing features using AI. It leverages Large Language Models (LLMs) for planning and coding:
-   **Gemini 2.5 Pro (via OpenRouter)**: Generates implementation documents (guides).
-   **Claude Code (local CLI)**: Writes the code based on the generated guides.

The tool is designed to be placed in your project's repository (e.g., in a subdirectory like `auto_feature_tool/`) and run from your project's root directory.

### Process Flow

For each feature in a provided list:
1.  **Generate Implementation Document**: An LLM (Gemini) creates a detailed Markdown document outlining how to implement the feature. This uses the entire repository context (`repo_contents.txt`), a project-specific context file, and the feature description.
2.  **Save Document**: The generated guide is saved to `docs/guides/{index_number}_name_of_feature.md`.
3.  **Code Implementation**: The `claude-code` CLI is invoked locally. It's given a dynamic, temporary "slash command" which instructs it to:
    *   Read the generated guide.
    *   Implement the feature.
    *   Adhere to rules specified in `CLAUDE_AGENT_RULES.md` (testing, venv, verification, git).
    *   Commit the changes.
4.  **Repeat**: The process repeats for all features in the list.

### Setup

1.  **Prerequisites**:
    *   **`claude-code` CLI**: Install globally: `npm install -g @anthropic-ai/claude-code`. Ensure your Anthropic credentials are set up.
    *   **`jq`**: Ensure `jq` is installed for parsing JSON. (e.g., `sudo apt-get install jq` or `brew install jq`).
    *   **`git dump` (or equivalent)**: You need a command that produces a `repo_contents.txt` file at the root of your project. This file should contain a textual representation of your repository's content (e.g., output of `tree -L N --prune -I 'node_modules|.git|.venv|dist|build' . && find . -type f -not -path "./node_modules/*" -not -path "./.git/*" -not -path "./.venv/*" -not -path "./dist/*" -not -path "./build/*" -print0 | xargs -0 -I {} sh -c 'echo "\n===== {} ====="; cat {}'`). The path to this file is configurable.
    *   **OpenRouter API Key**: Obtain an API key from [OpenRouter.ai](https://openrouter.ai).

2.  **Copy Tool Files**:
    *   Copy the `auto_feature_tool/` directory into your project's root.

3.  **Configure**:
    *   Navigate to the `auto_feature_tool/` directory.
    *   Copy `config.sh.example` to `config.sh`.
    *   Edit `config.sh` and fill in your `OPENROUTER_API_KEY`, paths, model preferences, etc.
        *   **Important**: Add `auto_feature_tool/config.sh` to your project's `.gitignore` file to avoid committing your API key. The provided `.gitignore` in this repo already includes this.

4.  **Prepare Input Files (at your project root)**:
    *   **Project Context (`project_context.md` by default)**: Create a Markdown file that provides overall context about your project (e.g., main technologies, purpose, high-level architecture).
    *   **Feature List (`features_to_implement.txt` by default)**: Create a text file listing the features to be implemented. Use the format shown in `auto_feature_tool/features_to_implement.txt.example`:
        ```text
        Feature: Name of Feature One
        Description:
        Multi-line description of feature one.
        Details about what needs to be done.
        --- FEATURE SEPARATOR ---
        Feature: Name of Feature Two
        Description:
        Description for feature two.
        ```
    *   **`repo_contents.txt`**: Generate this file using your `git dump` or equivalent command at your project root.

5.  **Review `CLAUDE_AGENT_RULES.md`**:
    *   Located in `auto_feature_tool/CLAUDE_AGENT_RULES.md`. Customize it if needed to better suit your project's specific guidelines for Claude Code.

### Usage

1.  Navigate to your project's root directory in the terminal.
2.  Ensure your `repo_contents.txt` is up-to-date.
3.  Run the script:
    ```bash
    bash auto_feature_tool/auto_feature.sh
    ```
4.  The script will process each feature:
    *   Generate a guide in `docs/guides/`.
    *   Invoke `claude-code` to implement the feature. Claude Code will create a temporary task file in `.claude/commands/` (which is cleaned up afterwards).
    *   If `HUMAN_REVIEW="true"` in `config.sh`, the script will pause after each feature for your review.

### Notes
*   **Claude Code Autonomy**: The script uses `claude --dangerously-skip-permissions -p "/project:generated_task_slug"` to run Claude Code. This relies on Claude Code's ability to follow a complex, multi-step prompt (defined in the temporary task file) that includes reading files, coding, testing, and committing. The success of fully autonomous operation depends heavily on Claude Code's capabilities.
*   **Error Handling**: The script includes basic error handling, but complex failures within Claude Code might require manual intervention or inspection of Claude's logs.
*   **Idempotency**: The script is not designed to be idempotent. Re-running it for the same feature list might lead to duplicate commits or unexpected behavior if features were partially implemented. Manage your git history accordingly.
*   **Cost**: Be mindful of API costs for OpenRouter.
```

This completes the implementation. I've created the directory structure and file contents as planned. The bash script provides the core logic, using helper files for configuration and AI agent rules. The README explains how to set up and use the tool. The `.gitignore` is also updated.